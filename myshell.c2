#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>


//struct for holding key and string
typedef struct {
	int key;
	char* strVal;

}simPair;

void printError(){
	char error_message[30] = "An error has occurred\n";
	write(STDERR_FILENO, error_message, strlen(error_message));
}

int isMult(char* tok){
	int i;
	int isM = 0;
	for(i = 0; i < strlen(tok); i++){
		if(char[i] == ';')isM = 1;
	} 
	return isM;
} 


void runCmd(char* cmd[], int len, int output){
	char buffer[4096];
	if(strcmp("exit", cmd[0])==0){
		if(cmd[1]==NULL)exit(0);
		else{ printError();}	
	}
	else if(strcmp("pwd", cmd[0])==0){
		char* err = getcwd(buffer,4096);
		if(err==NULL){
		printError();
		exit(1);
		}
		else{
			char *nl = strdup("\n");
			write(output, buffer, strlen(buffer));
			write(output, nl , strlen(nl));
		}
	}
	else if(strcmp("cd", cmd[0])==0){
		int err;
		char* dir;
		if(cmd[1]==NULL){
			dir = getenv("HOME");
			err = chdir(dir);
		}
		else{
			dir = cmd[1];
			err = chdir(dir);
		}
		if(err!=0)printError();
	}
		
}


int main(int argc, char *argv[])
{
	
	FILE *input;
	if(argc !=2 && argc != 1){
		printError();
		exit(1);
	}
	else if(argc==1) input = stdin;
	else {
		input = fopen(argv[1], "r"); 
		if(input == NULL){
			printError();
			exit(1);
		}
	}
 
	int BUF_SIZE = 512;
	int OUTPUT = STDOUT_FILENO;
	char buffer[BUF_SIZE];
	buffer[511] = ']';	
	char *commands[64];
	printf("myshell> ");
	while(fgets(buffer, sizeof(buffer), input)){
		//printf("Line: %s\n", buffer);

		if((buffer[511] != EOF) && (buffer[511] != ']') && (buffer[511] != '\n')){
			printError();
			//printf("buffer[511]: %s\n", buffer[511]);
		}
		//SPLIT UP STRING
		//FIRST, by ;
 		char* cmd = strtok(buffer, ";");
		while(cmd != NULL){
			
			char* temp = strtok(buffer, " \t\n");
			commands[0] = temp;
			int j = 1;
			printf("i:%d \t%s\n", 0,  commands[0]);
			while(temp != NULL){
				temp = strtok(NULL, " \t\n"); 
				//printf("com[%d]: %*.*s\n",i, len, len, tok); 
				commands[j] = temp;
				printf("i:%d \t%s\n", j,  commands[j]);
				//printf("temp size: %d\n", strlen(temp));
				//printf("isize: %d\n", i);
				j++; 
			}
			//HANDLE CALLS
		
			runCmd(commands, j, OUTPUT);
		}
		printf("myshell> ");
		

		//printf("%s\n", tok);

	}
	


	
	
	/*char buffer[80];
  	//write last char to x for overrun check
 	buffer[78] = 'x';
   
        simPair *sortArray;    
        sortArray =(simPair*) malloc(sizeof(simPair) * 10);

	FILE * input;	

	if(argc != 2)
	{//incorrect number of arguments, print usage
		fprintf(stderr, "Usage: mysort <filename>\n");
		exit(1);
	}

	input = fopen(argv[1], "r"); //open for readint
	//}
	if(input == NULL)
	{
		fprintf(stderr, "Error: Cannot open file\n");
		exit(1);
	}
	
	fgets(buffer, 80, input);
	

	int n = -1;
	int max = 10;

	//make a simPair
	simPair temp;
    while(!feof(input))
	{	
		n++;
		if((buffer[78] != EOF) && (buffer[78] != 'x') && (buffer[78] != '\n')){
			//over 80 characters in line
			fprintf(stderr, "Error: Line too long\n");
			exit(1);
		}
		//save line
		temp.strVal = (char*) malloc(strlen(buffer) + 1);  
	        strcpy(temp.strVal, buffer);

		//split into tokens
                char *tok = strtok(buffer, " \t\n"); 
		if(tok != NULL){
			if(isNum(tok, strlen(tok)))
			temp.key = atoi(tok); 
			else temp.key = 0;
			//printf("%d: " , temp.key);
		}
		else{temp.key = 0;}
		//printf("%s \n" , temp.strVal);
		
		//check size
		if(n >= max){//need to realloc
			max = max*2;
			sortArray = (simPair*) realloc(sortArray, max*sizeof(simPair));
		}    	
		sortArray[n] = temp;  
		//write last char to x for overrun check
		buffer[78] = 'x';
		fgets(buffer, 80, input);
		
	}

	fclose(input);

	//sort array
	qsort(sortArray, n + 1, sizeof(simPair), sortFn);
	int i;
	//print array value back out
	for(i=0; i <= n; i++){
		//printf("array[%d]%d: %s\n",i,  sortArray[i].key, sortArray[i].strVal);
		printf("%s", sortArray[i].strVal);
	}  
	*/
	return 0;
}

